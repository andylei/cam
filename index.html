<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="bower_components/tree-multiselect/dist/jquery.tree-multiselect.css">
  </head>
  <body>
    <header>
      <span class="title">Camparison</span>
      <div class="control">
        <button id="control-filter-open" class="dropdown" >Filter</button>
        <div id="control-filter-container" class="hidden" >
          <button id="control-filter-apply"" >Apply Filter</button>
          <select id="control-filter-select" multiple >
          </select>
        </div>
      </div>
      <div class="control select-container">
        <label for="sort-by">Sort by:</label>
        <select id="sort-by">
          <option value="model">Model</option>
          <option value="size">Size</option>
        </select>
      </div>
      <div class="control select-container">
        <label for="expansion">Expansion:</label>
        <select id="expansion">
          <option value="max">Max</option>
          <option value="usable">Usable</option>
        </select>
      </div>
      <div class="control select-container">
        <label for="control-color">Color by:</label>
        <select id="control-color">
          <option value="model">Model</option>
          <option value="cam">Cam color</option>
          <option value="none">None</option>
        </select>
      </div>
    </header>
    <svg width="960" height="500"></svg>
    <script src="bower_components/d3/d3.js"></script>
    <script src="bower_components/d3-tip/index.js"></script>
    <script src="bower_components/jquery/dist/jquery.js"></script>
    <script src="bower_components/tree-multiselect/dist/jquery.tree-multiselect.js"></script>
    <script>
     let COLORS = ['#2a80b9', '#8f44ad', '#c1392b', '#f39c11', '#27ae61', '#2d3e50'];
     function prop(name) {
       return (obj) => obj[name];
     }

     let barHeight = 20;
     var svg = d3.select("svg"),
         margin = {top: 40, right: 20, bottom: 40, left: 0},
         width = +svg.attr("width") - margin.left - margin.right;

     let container = svg.append("g")
                        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

     let NUMERIC_PROPS = ['weight', 'strength', 'lower', 'upper', 'range',
                          'usable_lower', 'usable_upper'];
     let DATA = null;

     let CONFIG = {
       sortOn: 'model',
       expansion: 'max',
       filter: null,
       filterItems: null,
       color: 'model'
     };

     let toolTip = null;
     window.closeToolTip = function() {
       if (toolTip) {
         toolTip.hide();
       }
     }

     function bindById(id, evt, handler) {
       document.getElementById(id).addEventListener(evt, handler);
     }

     function toggleFilter() {
       for (let sel of ['container', 'open']) {
         let selector = 'control-filter-' + sel;
         document.getElementById(selector).classList.toggle('hidden');
       }
     }

     function bindEventHandlers() {
       bindById('sort-by', 'change', function(e) {
         CONFIG.sortOn = e.target.value;
         rerender();
       });
       bindById('expansion', 'change', function(e) {
         CONFIG.expansion = e.target.value;
         rerender();
       });
       bindById('control-color', 'change', function(e) {
         CONFIG.color = e.target.value
         rerender();
       });
       bindById('control-filter-open', 'click', function(e) {
         toggleFilter();
       });
       bindById('control-filter-apply', 'click', function(e) {
         toggleFilter();
         let opts = document.getElementById('control-filter-select').selectedOptions;
         let values = [];
         for (let i = 0; i < opts.length; i++) {
           values.push(Number(opts.item(i).value));
         }
         CONFIG.filterItems = values
         rerender();
       });
     }

     function setupFilters() {
       let select = document.getElementById('control-filter-select');
       for (let i = 0; i < DATA.length; i++) {
         let row = DATA[i];
         let opt = document.createElement('option');
         opt.setAttribute('data-section', `${row.brand}/${row.model}`);
         opt.setAttribute('value', i);
         opt.textContent = `${row.size}`;
         select.appendChild(opt);
       }

       let opts = { searchable: true, hideSidePanel: true, startCollapsed: true };
       jQuery(select).treeMultiselect(opts);
     }

     function loadData(cb) {
       d3.tsv("data.tsv", function(d) {
         for (let prop of NUMERIC_PROPS) {
           d[prop] = +d[prop];
         }
         return d;
       }, function(error, data) {
         if (error) throw error;
         DATA = data;
         cb();
       });
     }

     function buildColorMap(data) {
       let models = {};
       for (let row of data) {
         models[row.model] = true;
       }
       models = Object.keys(models);
       models.sort();
       let colorMap = {};
       let i = 0;
       for (let model of models) {
         colorMap[model] = COLORS[i];
         i = (i + 1) % COLORS.length;
       }
       return colorMap;
     }

     function decimalAdjust(type, value, exp) {
       // If the exp is undefined or zero...
       if (typeof exp === 'undefined' || +exp === 0) {
         return Math[type](value);
       }
       value = +value;
       exp = +exp;
       // If the value is not a number or the exp is not an integer...
       if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
         return NaN;
       }
       // If the value is negative...
       if (value < 0) {
         return -decimalAdjust(type, -value, exp);
       }
       // Shift
       value = value.toString().split('e');
       value = Math[type](+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));
       // Shift back
       value = value.toString().split('e');
       return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));
     }

     function round(v, digits) {
       return decimalAdjust('round', v, digits);
     }

     function rerender() {
       let data = filterData(DATA);
       sortData(data);
       let numRows = data.length;
       let height = barHeight * numRows;
       let innerPadding = 5;
       let frameHeight = height + margin.top + margin.bottom + 2 * innerPadding;
       svg.attr('height', frameHeight + 'px');

       if (toolTip && toolTip.hide) {
         toolTip.hide();
       }
       toolTip = d3.tip().attr('class', 'd3-tip').direction('e').offset([24,0]).html((d) => {
         let rows = [
           `${d.brand} ${d.model} ${d.size} (${d.color})`,
           `${d.lobes} lobes`,
           `Max range: ${d.lower} - ${d.upper}mm`,
           `Usable range: ${d.usable_lower} - ${d.usable_upper}mm`
         ];
         return '<span class="hide-popover"><button onclick="closeToolTip()">X</button></span>' + rows.join('<br>');
       });

       let y = d3.scaleBand().rangeRound([0, height]).paddingInner(0.1),
           x = d3.scaleLinear().rangeRound([0, width]);
       let upperProp, lowerProp;
       if (CONFIG.expansion === 'max') {
         upperProp = 'upper';
         lowerProp = 'lower';
       } else {
         upperProp = 'usable_upper';
         lowerProp = 'usable_lower';
       }

       x.domain([d3.min(data, prop(lowerProp)), d3.max(data, prop(upperProp)) ]);
       y.domain(d3.range(numRows));

       container.selectAll('g').remove();
       container.call(toolTip);
       document.getElementsByClassName('hide-popover')

       container.append("g")
               .attr("class", "axis x bottom")
               .attr("transform", "translate(0," + (height + 2 * innerPadding) + ")")
               .call(d3.axisBottom(x).ticks(20))
               .append('text')
               .attr('class', 'label')
               .attr("y", "30px")
               .style("text-anchor", "start")
               .text("Expansion (mm)");

       container.append("g")
                .attr("class", "axis x top")
                .call(d3.axisTop(x).ticks(20))
                .append('text')
                .attr('class', 'label')
                .attr("y", "-25px")
                .style("text-anchor", "start")
                .text("Expansion (mm)");

       container.append("g")
                .attr('class', 'grid x')
                .call(d3.axisBottom(x).ticks(20).tickSize(height + 2 * innerPadding).tickFormat(''));

       let bars = container.selectAll(".bar")
                           .data(data)
                           .enter()
                           .append("g")
                           .attr('class', 'bar')

       let barRects = bars.append('rect')
                          .attr("x", (d) => x(d[lowerProp]))
                          .attr("y", (d, i) => y(i) + innerPadding)
                          .attr("width", (d) => x(d[upperProp]) - x(d[lowerProp]))
                          .attr("height", y.bandwidth())
                          .on('mouseover', toolTip.show)
       switch (CONFIG.color) {
         case 'model':
           let colorMap = buildColorMap(data);
           barRects.attr('fill', (d) => colorMap[d.model]);
           break;
         case 'cam':
           barRects.attr('fill', (d) => d.color);
           break;
         case 'none':
           break;
         default:
           throw new Error('unhandled coloring type: ' + CONFIG.color);
       }

       let labels = bars.append('text')
                        .attr('x', (d) => x(d[upperProp]) + 5 + 5)
                        .attr('y', (d, i) => y(i) + barHeight + innerPadding)
                        .attr('dy', '-.35em')
                        .text((d) => `${d.brand} ${d.model} ${d.size}`);
     }

     SORT_FNS = {
       model: (d0, d1) => d0.model == d1.model ? 0 : (d0.model < d1.model ? -1 : 1),
       size: (d0, d1) => d0.lower - d1.lower
     }
     function combineSort(first, second) {
       return (d0, d1) => {
         let v = first(d0, d1);
         return v === 0 ? second(d0, d1) : v;
       }
     }

     function filterData(data) {
       if (CONFIG.filter) {
         let f = CONFIG.filter.toLowerCase().trim();
         return data.filter((d) => d.model.toLowerCase().includes(f) || d.brand.toLowerCase().includes(f));
       } else if (CONFIG.filterItems && CONFIG.filterItems.length) {
         let items = [];
         for (let i of CONFIG.filterItems) {
           items.push(data[i]);
         }
         return items;
       } else {
         return data.map((x) => x);
       }
     }

     function sortData(data) {
       let sortFn;
       switch (CONFIG.sortOn) {
         case 'model':
           sortFn = combineSort(SORT_FNS.model, SORT_FNS.size);
           break;
         case 'size':
           sortFn = SORT_FNS.size;
           break;
         default:
           throw new Error('unknown sort type: ' + CONFIG.sortOn);
       }
       data.sort(sortFn);
     }

     bindEventHandlers();
     loadData(() => {
       rerender();
       setupFilters();
     });
     /* TODO:
        control expansion bug
        make select arrow clickable
        make it look nice
          rightmost label
          hover over
          helper text
          intro text
          background
          imperial / metric
      */
    </script>
  </body>
</html>
